<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"ffb805515bddde0fafe8b7a92c7bc627f7f96037dabb3a2d86fa3d7e991478ba887efbb1b1bd15bc194ae69c280308e90a4be867d4533a1a7b38b684f54329f5ccf300c6160af87f8224ecf46a02da982d9a7226aa7f0bf2d8eeb74fca49110a900b8763bc701dd28ec5f05b41941e29b98d5acd82c03bc36aab1317afb83a7f86b83cb9476a3444b6f996d5eec3813879c296056b6b5010058a2e55844d45d3121e945570dbd0cc3f89758daf198e0476e7d82cb52160785e9f377020f1558a8e808b8f6a481040f87ecae3f257766f4654a8f27239b726a47bbb0595160247a5c1a0ace48bdb2ec68b597d869b102a27f4ee5471156c7df47de5c2dccc0b9edb73a0f27b324e3d231565757869d261160b3033850279b3f7d524c766012d4a9a7938f62d18ff812440d7fdd20791d2762dad64a910de00f3b344d7632eb81f86efab88ea3ac2cc26b175216edb3e8795e5332114e60cd6878f55632e7329581b445cee6337b9ea95acdce8ee6db817b842d39e55669c1ed263af8c20fc024b3ff0c12b0cc56cd2ef00d25fa46674a59c57ee38e2ca9fed299db7652b332733869cd2e605a66ecb544ff0648bfd8b214a0111745de7bc5277a9963288520aab8b8ba9779316e09bbee832ab1fcdf351c25e59dc27cb882f692a9c849e5357a34013563c2af8dffe53ede5247f3b8d362409168c7bb858a57e2fad82fac9f955a777cd6be90dce09f1810c5c59383e67eb617e484b6fb58857431ee4f15f39ff3a62396e58882a2b5347cabb4d95a4577d82cbc2cee4f69231ca0cbd7083897f09aa8a12b1e2e29fd77c37bd1b229aede07692776a5b4da86b434b7cbfe2597ef03ff1765a96be09e28f5c2f182654be021130ae1523dc00c6526e5bcd59d4ff2d5ddb7ed1c223da79b6bd8d94c1a1b804b751b8bea8ba95c69a68cb2398833f1c4715f4ac5595281c399b25ab892fedfeece014b8146e15767e636aba5bdafd54db98d043e9a9ebaa0e6c2c84b515e61e32fcc700a0a8d2b217dcd153e3a2a75f4a88720257024d5c42310b2573dd77f1cabedb7187e74e4d7e660c9b95951597f1dd225224d8e6bb9e209935e8916cce4e17e9a2e9ee49dd8c17e8734265943701026af3f87c1b28e62fe55f912878591b10eeffc7285fd39391f5969932cfe2c729b432765d8370839574820570aeb269e125afcaf0ba8c4e139642df88431439b0e80913e0077b1199bccab09ce5d3e64bf20ef8d9b9a42fea35a19e88a2e65782fd0798e191c557bd3c806e05d678cf6ba89f9e5933fd71f474f49e1d20a3a4cccb20558f5bd28c7a1f02b016663f9d2a1b58618556fd0502a7cbb418aee9f919f8d42baba8b4642e2b08f419ffc756a2b1811d8e50c694f0b328e6f94b05543f863cf6f12ae3a1a5064c3b5a9fbbf784d5088659940e3317827a1a982194b29481c57847bfdb2221eb197aeb7582cf1fe1e33213f0b542777ecc9d60755ce23f37f9b0684fd900ec635fef92ab32c4ea4994c52cce4ae952b4d73e27ca2ffdc6111fc366dba3e80ffd9bdaad0e8c26beddb97fe849f4fb39534970185e26736ac5c4a0a8209fcdc5573b1abbfe38fcd4399f4783f296bc80c71b6acd5e72452ee37a3ca812f1d8bdc84c9219aa809aab5a5690f5a469d6518b342cf50a38cd42b93d1b7e8ca9ccb15d83daa6808d331d05f68731e5accbfb97940cea322010ffbe8c839a49bd178c2227eb7ba723f7938d66be3162c896da30cfaf01eb87feefd03f8b7a955dbaf4487c7fcd0a434dd11f84e85e81c6982ddc834c171e56f6813a23a2ade71be4d4e902b588747f34b3d746d4aab03b16624c1f83f6d0256cb00e18a11441606776a316eccdcc85ec1b6a8d4819f68a2fd4374a6414067c307da7febaeabc6a613ea30b2cd4c2cd75598b6e91f3ed76f846a7bb128c88895df2693735a49e89be2d3a87d717bdfbf6d1a5ce019322b6d2e27ec0e142941f4e19c1130e8b816b6ce59c77a732c038bb71ffb3d5073cc2b2c8134b0a234f9cf20c8af30cf018368a1d06f849449549022a820459ddafbe104b80458888d0bcfd9e071be8a49ab28c13cd822891431bdc7c07976910e240a32fa64a3726bc86980f90d45c0978f4cb3af8efa240fc6b94ff3957fa032d7cc3c4705903446c89be463dc3b54e56eaaba2dec805a9ef7b4daac946c46a091e0f17d7502fa3d4a385a83f86832ab0ba91231e0b29b5a0a4287a468a2f3747386f6d97dd6e5cf8e38f5ce602efde1fd8e1dd837355ec8848c3056fd51b7bec17db66f45793584cc649fe99dac27fc7e927b49b7f5237eedf82360f4e7ce3bf132b283b95a9d52fe559737ebd96d22a4223e7fdf2baf4c625b1e59a5b44e35fe4c79e41cb43106530f08b3d45309883fcd2de1cb6fd42cb798b710e7e65e273756be9db98898e5d56feb788830be216a002ca6769e3ff2ed860c9b0d309818114f3504f3c34ef646ccb9b23f978df97d2c369529aefea1d8c7ddc17d372e1d136da5b711e354a19b3f812088fa0941f4d992e624e693645601255c9a9a1a3139008e378e8718c7d71c71609ed8eea9369ba1c51e93ed84375a80487ad8dd68809af8c3698f094973a74876b7fb5afab93b41b8360e93f65c162c5252054cf6895cb9f03a86b6ddee07dc353a29d5544b4a1d5c9e855f78ab93939c30decb5c933907237ea03d172db63f7da4c58f59520ba26797816cb0cfdbeac36123c20915a03f20d790d2044021d8576851d80b1a0d347cb1b572fee7e92090c4ea25b5940472efd060dc3fc6bcd296ce146502e9e889bda8a23ea916bda8535c75033aad0ce3d2ba6cc9f6442741808481820308bf7bbe59ab07a3acfa6f42079655fab20c5a544475513692ad6c923d0a7b63d7b8e879eddaf0e9166f3e44a278346df6b48a3de9cc9dadb7d073944e3aab4534be0832a65ec2f4b36814114b6ef88ddf22688dbbbf35d84485cfde0e824a60504f9fc8964c09ca2382e1964085dc9c19a3b911a7ab7d66467844f90f2cf15ec781743c8351f3f030c18bba6fa885ffc7c5504f99e3b63c8012fcad74bbcac1011f3219550808496639ee6cbca6ff36286ecd282777983302e633239ec938d281900090fbbc2e064c51f1be46a38e3c1b81c333287335209da6a6ff7e716e70829009c6fb8e60beefa3e6ded4b702cbfbe27523fe97952e207506fddc230946bc79e1ca2bf432decef3c150c1cb2d5877de2684cf19054e15051af77c0e2992d422e77a60b5f7e0294dd358ade794cfaafba35aca425a23aea8a334d216df59eeff8eb35ba36570e7966f812db87e423ab1968d60e3280d3a687161445486d1350342ee0582faa22c61210b187e0ba08dc4329f27858aacee8171bfdbe38641bdb48e7a19bcee9ead952711ac8a3b5b4ebfc9a45b477a60a9aad3ba5a376c4fbeb6331b99a68046cd2d35d6ed6bb0d1bb11311b546e44ba17abefabc35c2fb40778bfa0ffdf684dcec0fe2b4016d4d1aad282d1304bc1b90ea2859fd2a62a900b95077acae53f17efb3af5cece5eeec3a044dd5fe3ec8e6e963de83e080f4623e0e20fdd2788fe6b76da2fd10243c5c1794b9856e6c0e704639f7749fd23d6267f4f022457de3408ccfdcfec84094d1dffbd53071fec6fd33b9773028dc0cf74b1e21d7dcd81d96a9d2f76cc44e439c41384bd29d7cdac47c4ae4b9004b31da67a9ec2981419ddf0c8f9b9d1e05a1e7ceb52b1a7bb26d5ec75604dc10b56c81728912ebd6c8e1ebb44ac537fd89338f6ecbf6f46d1bbedcbcbb7c537ade1ac39b20a1510031dfe0346ad46e6da6ed9ee06abee119ce68f5ec883db6ed4d0a6c715f2fc073803c1ba25952131a8ebcd7166d8908cd5b0468a3ff4730684c5725b489f3c49639a322ac846f2807eb7ba5f223fbbc1ae8aec76e9ea23b75f7ae238f68696537ca121d4189451b223fc37c6fb8911e52e926669d67c53717052c6c330e7fd19820ac9e22d538b84119f146d37f20ad93bcf44d8e323df5f71c45f6c31b9d5de76d53abed0491784e7d780ea72e5e9fafcbc4e2962dcab318357d6ad660ee7a822dba55348a53406ae62bdc19362d7e41f83ad89040559cd2cd91273a81879bb4c16227956c12b4075fd7374124862d663fce7e994812ee01f72396c13fdb5bd3c2967974bf1c0483d42025653de412a1b30def6f0384b2a8f12a99a3182b36edeefd4ddde9698fc951ba45398ea47e95c2976e56b42aa68449520453fdd78b992dc5207f2b5c43ddded50229122f8454d70a539c02e5216e1253f6068563b53c00cc48b27f3a95e7202d4759c840d3582afb8030371e9a92bb038e0125a341f6814ec89c2035c653f9b6fa44bf18ab0ff98a218b39fb34c8adb3b3ce73b23b49c2633bcf144344c69488fcbfb2321f9a87d23cd768e807225b644b1d9a546e87e38950e1c12edff1ded49999c0a40ed347892527850d0ca1864ef5d32dca05b9275df9080eaf0567ef6a4db5dc1c6fe225f4d7c411523a032b5499a49c445a809c6ca2f6df8df775f5a95acfe14356690897a919265bd40d335774141e873f89b4eda7598922e0ea296db818d4341cd1b000e0a713deba84230b03cee1f4d70d3d8bd7780983555dd0e50f2630cc08b7146112f0378b0862d5c5428b455a669fd58c15caed863a0012e4df44cce4abc2f9335d96ac66c404ea1faacf928e9db48d8676de4583ab5a67e615f6483a70e540d0e4ed467b9edfed22fee56c961e65e4624baac6df3afbaabf2a04070d8e7025eb10bc80a59a85aa38543a369ce1d3eb62029ab999d25b73afccb5d765d3c8be75d2760901ee05e0253939d170679168664f2b3314ef038f8bd2dda17e749019c85d2c76626c82f6c1f86e74e3c1be834c04dbc6dd8287df897d863c834d045fac0ae295596773c499cb5db3a801ddf2ef26ad37b6570d48d5782d98832ddc9573a6a4d21771f0515a348c93fdedcdae17522f533fc414dffd1cef8132451a5b03b1c3134944a823f99b8734cd7ed30cb5017afee00f1e7c6ab3cdfd3fa49ca0e7bccd40c8d39a6aded8228c8cfe2934ce3a810316de17c873ac174fd806086c6bdc6c01b4e694fe2d1bd5d117652927ed186f2ed5cecbaf4cf4dcb1b454d282e501eb20e1228fbfafb6290dec1625255fb9abdcd008a0eba664a20fc378351f1b93bdf46bb0d9376ac682a99817cc941193a9dac6615c1ca02e33a5eda11c8a98ccd01d74eceaa64308bbac85ac2970efcd92aa2ecc81280f82967f37a69619b8433a02aecfa9cdca2ea7c05ee7655c48e43049d293d25aece5caf1baddb6e8d7e3aed8aeeecd21c0a08bf619f7cef96103cf744051ae1d839bcecbb9516c88b2c6f06c60a3d2d45a4853ebd3b28dde127b3c1c36a70af682c816fa5df80e7209adc1cfa871e7278afdc5d4840c502fb7bc14f925426e2f144764af8bdbd01573868aba2bfd79f78f1b0fdae19a7db2d43f2c34d3aceef0f09873b441a45464ab1fcf7181ea249d1f3fbd8e6bda019e1883deb9d4474e45aa2785b6754baafa4eb2cf7b856118666759b49eb8ce023e5589be0f7af9401aef131cf8ac854791c44acdbe8a535b14297098502542417bbb311c5fc4b8c9f238522d4abc706319136dde8c82c929f1f0fbb76d5c5a0affd5e55cbc468df707414c56bd2e874f86b16168c59542592c9803367794d781dd145021ffb6df6243c0b77878f1e68e715cb4a19897326fa0ccc257dcf1a0c6ca7bd91615ef0f7645c2094bbfa4b6a11d4ad1f0243ac64f87e1272ef22fd3250cb01d80817482013a27b372932989be651bb32db25b53e237da9dedd2764eea4712e11577d4b2c5f52c4e21d9d890516ba4a75943bd37b5b68731ec968e9b354afc3de93929cef22717c134d1b5c8d8444e4d8070474d52d4a5c44be9cead6168e012fb5495a6274d8614af754b1e4182ee2b026fa4b1e8019945d83ead04c48ec485fd00bce2812bd6fe51b7a775d614d73e37ce6011330ed044fe61c1ffe610e367f90c29db63ca18be77f76a82c068628d0f3e5c871a5ec75b23f21d2d981790cb66a932442a2be0f6db5b2027f6d5fedfd853c0ad0781cf02cd99a858bb3189f0408376a3058d6665a23a05230c30485a50430ac98cf56c64f614ca317abc1d81f58a7d90447f0a06fa4c6eb7be4e00946ca3a37c17f4e03464033208ac1130766cb02d32d25ecaff70ac21bb67b6c7b03405bc38487fd1a4c19f07b1cd113a9679c9bffd023c8701a943ad744e528b8fa873d1426f3b0630c977b79c6b2947f95c1a5605ab0f307cbd62226b31dbab5883dc2d04e377d7309f6973de397e2dfb55de7993a1c7a9580a56af764f30215e69d64cc82aeba00583c169d3e2ae1adbb7c125fca0edcc0196f4eb36353555ba5cb6688bb071e099a26329ebd6088f85cc5a6ed740df89e87314a1ee230cd8abb10ad9dd6ae71546e76c252048300c29bb02f843a79f4508d0f7d972f552b789df4db91aee5e44fda4bd4aa1f5154ee516dec4b4f6fcdcf3e226a3d7afb5efe7083188037b8ebb60e5668a43190f23c6c858fb68e08d739746d2586a8d7de471d245734a3238fccdc3747f01f7926e58d25e26078a3434f7c00b9f8cab0f196a2cde453b80149938a0b6854555bbb7a78b14d83695b3fc8d3fb786616bbac816a78d918861ca01f1fca99450fbddd22abbd89454375f1dfbec769fd71cf76bd867dfa514bf75e6d6e831d4d91fedbfeee78fb7cd40eade61a48e4db9d0fc0ac21a79062e28297807dae9f7830e1f6d0e2225fe08b53923be11dc71a6e5c8cdbb27dd09e274f697302dba21f2235f2035f7ca7ed2e3c9ba18bd215f0db2d4e41a01356047c3be05156659ff2c5c5d11d81736c6c5b979a48247ed3bfaefaa6fb4ad3698bb3a52b0ff81cdbe77cc1f967693382b271936ba15a31e4fbe00c7f72157519c792fbd4a17198213a90e21f1f1759b99d1b4af131f028269330a63b02baf1a1c2ca4bc3049986fbdd836ee584a0bd25e5b7bc246bafa5d5a6482eed8bcb72bc5778ad7c6cdfd2f7c548467987c5dc798b905371286f31c29d69f2db1b41cb4aca688fd51f97d4bb1fb62c6712d298a0bf70596a06dbe700a771f72037a3b15875297bf5bad3bef29ed96392d12babeb5e3fba972c21e5b3eb339f6deca291b8d911dcec75dbcc28425f47d2b1e08c796afb3f702575835a6cd482b63709d96d0aeb2f63898e6e037d5ea8050f7132c2f4582ce6b0a0a9025170288a3953cfacf40e18a3afe5225378b2e3ce5c6531fcd8a963ade7a819629bb090ed5fb6ec7479053acfff9abc88f53ae60afb86c42e2e88508236b92c11ebcfd994e832263e290ae5e1e3af85beb565c3cbde4add74655bcb11b13f3d4b633f76deaa4960c74bc254650edb3fc7d40556f41b029e9e97227ac3e53852baf76844572b25e9cae57b49bafc72f5091281c0a96a75ed0be4411d32174e7535fed558017c2222552f8a705b04c56209f75b7353af6feff07ef6489a7c9bf702b367a6a8625e7930b7e4c2bc6a719d35519e56509f4a7ca4e6c3686864389547c9a89293e315d73955fb8bca0d22cf2d72d6bcd880514cce03025eab74876b9723a130a2305f478d0d8917a1a938e8171b0a9ca9bb4bc18e05632656348ada57420b3dded80c982d422cd96e326e837fddb71bdcc935345b68c18fd9d2ca184eccaade05d71a68e9bd3408d52d19c074a7fffec0327ef3904b4775efb0ca98a7b6ad5a144053559de747bb387a6ce3bc38803efea06ba03ac32ebedf7281f239b995025c1132802a3803be9fa80a9300ac68711f030db642ad4bd8e667514c819c297ba8e52300db4a2a791fd6d42d3ddeb4cd3f361230028461d727ca2b5ea90a44b6a609f74647788245438dd5112d15b7e817541bba0c757b57f1adcd9621cafd847094eec363660ec13930a43081492874df824fc3e2078c14a301e0cb5289566d49bbb67f1f034cdec2076c88ca4b013ebc7458d5031e22b067e6818c0d05cbd17d30ae58e83af344c396facd5ac0164fc30bdb1a37bb65cec3bb2f4d6645390303f93d53da60a0bc3b19ebde44206cb29d29f6279dee1dcf66ff56bede7448f7ad63c77432c1aece619c32f89f767acd269f14def3a87f0f80f7363c04f2de9387d0ed13e3fa1155e7ae0ad4ed013ce4b87e1ee459647b1ce8b0d455e1abc80a4f54135bd072e6f6d60976d372f57b40b24443af6733223117a4f9b071dbe857a1d5504070ad5329287e159d70a219cd0cc92e797584b3f445e0b10db4cd9b32087c203b6d04a5badd727fa538ec0cebebe4155abbc6c7905493ffd0c1ab84c15572a8fa34325f3e137d253c8f2bf9c0532fecfed66db678f9ed54428bc1182ffb9d4e34bb1899a193311d63d1264a0df77e125229c0e75589fa24ce4486022d0c8b721a0b52f8529daead2dc44d8a1d2f0db7997d82ec56411e29f9f016deb54a09896eec304489158e1cd011c5fc740f6d4edcc3e2c6610d3e2cb1dc2db09dd16821a21416a1efd1d3359eee0e3051cf7b75f4958e78f93ad2a75afab3917864b0b26f28496215d22e7c0260dbaf68d1da3812300d664aa9419fa8c1d2ba4a6bb0bea876f0e2d92b6db3a3f293a836a9083f4858c87f2a6e8349a2f833ceff25357af2c11c2feeec87915cec4cdb1979ccb6a67cd5a80a9fad1bf5798af421e595a300f96373fcb602546d1fd0723282f32a5d999746a527975a38b463edd951ae4c8cdef06b412901f4e92f3dc1bea934d4e9beaf9a3320218a656cc272c24e2aa2b4f881612c02e30b9e37358fd7c65b9876dbe8da0c0084a077e27a2659baa5729bd9655bb55f50e1b0569407549f7cf4722ac4b02d924872f65075f81ec4f18825a37ec1a7d057de6ee82ae0802310e39e5df450e6579fd40e0ad744a0fb2aeb1e7d65c455b40f6e61b1114baca04765c8fabad1f3c56ea1fb9591153923d6533872696f4b25ead3eee03b6c1fdb21699be7d8a83c32c4cd006297b8b972f2a8245769db0f6b70e3420d3f940946797be9fe504224ae589cffa01cee0a68fec1ca23c87e84eec029ed766e848a8fa4587cfe8b7a48a98f45ab655aa311ffe12dd129212cb530ed50958ab7556a3de5b47ee4fbb3f0a740030adec099fe31fb643f6848f5774bbd49385bdaa0a9d5eee0d0acd22e43d4f182e5180760aaaed92aadbf64ed326b86a131af28a5769f44a45fda2504f7d917fd01f46c1435605587ef9f44a4cab7436b0831ad7f893e1a3642c46dc31189abd46867ce5325fd1af47634306394b8bbead24aca182663e4fc645e8192b903dbb6b5533febdb09201030c36fb8ec36a2ece16f58e47f7a484870cbe7686a72fb53e0bcb14939f0bc80c9d4d09f238b7ceaef4b1d3dbcf70d7c74df7906937ec460017cb5fe988795e7e24b2af895f030ec04c27bda2e29af10fdff4aabc03c2432b11467af0cdb42340dcd13d6012e6ad7f2eb08ec9c95c76c183bd949944dc87cddf7c9d5949f2db82ace68b1b98e1dfbd842d2ae6988f38c8622b68a36d257d6004387a3ff55dc32fbaf055160bdaf425670c603562dfe2f6febc0d6974f88bff3b99a26d52aefec09c16b6a74d27680e523618eb08f09ea344d245aa603177d1ed76a2f1e6ed174edd1771bf38504c6b37d1dd1452ab836d0c8c0d97f156fc8345d2ff7d7c3d8d300437d223d0b6b2ae5bcc6fb301cf61cc95b353037343ca6b44d6bf3d81ab30cf1da55c1e80c2cb9db8deb605238a0cfddc723362f8b97d860832246f162e2f0817180e9e4bd776a6de15f0262c9db80d58c9271aef4c254348d933c020c184c643220f415548464f1aa2e531dcc0a4850353400cf258557d1b5d32bfb42dfe647ec49ff53a661f1719b1c3592bbb1c14af59088dfe5e3aa5d084342d8fe49a0649626c2645c4d7808ddd050ec19755da5fb0023b2d4f3a1a10abfcf5b0de6db66232245d9eaddb7807fa3823b50e5abfecc40289ab9103fb453e3ae9a1ca9ea4916d01e35d30e5fa12f500825fd650082fdf68c9b5c0b5d0235f22e0dcbbb21e73b1c44ab47663f74c68f5036bba8c70fb710a078415687faa696444ac9b4e3c81f18e21a5568880f0729902d756a4ea951c1436715b6347a4d73f5bf3353dd107bd57c35b0889a32d09a98ba86124781a0488a8d4bb66d81508db4dc28c00e3b9559e5d6a8db1ae73dbe8863d3223a462c5ebd532ba06c5d8fdf51e4d48e4271115f477277afeb10bdae7caf3a018b964c2bfaf2cd7e2b2dbe7c37f8d3c2bf884cebd27382a2a7b5a9177b71160285e2043ab176ee2f437141ddbc4a2b3d153d9bf7de57d65fc04bab480c27d35192592a860f80a3212df61743ece784c8cdf26f820dc9e89d0761ae182600ed62d23184f818afd6322505a32f9896692b52dc66f64f87f5e72efcfbcaa773daea968108b6c825dd480c30f406ae02135b2edae1ad2a5c79fd7f8d4743bea35f27ba2764820b0987dede17f7ee81cd00adf3157a8e9080a40db68e1c1e66a1e17e451267da5266218e85d67894b5bfcd5399693d70f3450b1501f2bd28f92a4c07ae7169ddd4cb30a866cc7f914d03e12778033ee001215f33653e9c285704b4adb57c0f69cab47d493f102c85a2205c191a27ad91c5709aad3d4dd90445ca4e7d21ffe1ce195439dddc79a6276fac6b4a78ce9701ab29807c95f7eb9018c7c78e5b85e43a10cbe0ea5c958c58bff85a9f228cddc6f17ec2ff83c560ea3e322df992f1dd382a266f4e23005640cd66ca24b8fb15b73d669140ac13eefe26001a5b233000c55474c513027b7ec1722f6feae51bbbae4261f446aa4994626c313f951df9cf3c55949047dd0ba40ca6903f1750e4c9568e4de7e3364f2a774fcb8566e4dcdcffe7744c3a6bd050b0780d092b50437b3a7b7dfbd338aad0380ebf8c3a4801c29f7a9fa9833069b987d59479b7cb3d10adcbc2d47c8a088f24a629fb83c676bd82cc975b5ef32d97c74025aabe5c0a88ce447a028d307b7f2cb01acf3e8b2e0fb5afcf0893b81509f3ff95c44d2f30c2e7478bcf5d74b579fd44a38ced5191f9714aacfb6d430ae2abb3ceeebf99fed66df56e395b393b7f2a005cab72c42cefa5eba076c6bb7e3bdcf60fbe6caea05a232b1dffb1cd9775e176d6a607351472f31c4460d1370592664cd25e64afe5afbd9e32726e66cde600f06a297371fc7f8936c2e7e3a8bf511ed9364cd84e5518a5533e6100c712c4e357e510cd904babbd6dbc86c567cb7b368c08bfa77aeb67aaa074f75baa4f06256ee511d6c4c20c371b44c05bda5f3db60bd5d088d03791ed30400ea4ca445597a65060bd67c5023452d6ccf936ad4a79ba2eb5d4c128fad44e2f706aedca99b515a7273e75a7686bf0ca192316677a553532632b01a4c8ebb00c3c7b5a4de4aeacb445f8b66fb63f12feac6c10956825b0eec30bab836ae6f78196ed43c2a68420db87a3b7e7cd39d8577058d5b95d4e9a9ef1f11f48076bc5f9b114c1faecc1f5c23689d020b90eacb13596493f392b80b1cb486acf56611b6330e9b4ca033fb3841c74fc0f2d94cb38fe627315e37eefb0b3e439691d47bac1e0581b90fff82e8f034f7517dae34c82a131dc7e49783110c8b2b716ad5e4c48be07baea15e6413f301f4a8ba6355a4de6d96a841872d64fe7f1ec14ff8dde7952d9e2b44f69ee6bb3af42f57abcb3f6e58dcf174ffb9dae489124ec366436e632643526cd0c690a4f21beade247d714d775ec1da1de104736e6490a026358c93c75a1ac0e6b9d73df6982bcac0d49d19d53f5743d021a38cab8c1b8765ad7ad19c8f274a69527386c65d5d48a737e503dd8aba2f6130396e70b2c1fdbb5f2ba9a2efd2eaa0514c5e77783410c296e46d2ea9b640ce0bac5c1fb386be3e68163a1dd7c8d4848253ed3b6d721e01d1f30dc97d0262d339c910747fb180d7a1b258a7aa77366bf151770bd3f7c3c4fa9620f1c6350de104739285bbee5265fcec0dc91cfa7b950d311930d739d776600a2208b3fd0499ae61968abcf4fc0b7ae3b7363a95215c5eb09384e960b23bb23f679e43c927a2c7d7ae34d99f764961e3c06fc5b00be2837bc9f3d9a4fb1975374b8db2ca5901c72cc2b423101eb76701e562dfc93c5e64bcc01453d58446f51f0fce2c97b7b0bf70d37ee41e92ddc34d5bd124f97290d27e6082498831748b6daf39255fac28de24f2d1f0071234e702cbaa7d458bfa606a50d30fef83ebe2d1b600d18294a158da4ff7793771e7f75a5fc12a4c5129afb1364df7ca911f5980b60f7bef19d2e96ba01506dfb62662fb2ed12a7d6e08c1aa4e8c9d01ac6ad9f96fb01a0d5123988d45aed093a68b82df675e6b4f2e0e8bdcd7874751eb8db36af523b0fdbce428e14753997cca46002e47a3c29cfa03519410a6ec2f8cca36b5528b552a55dc1b3115d9cc7ccaac5becb4c95d6a408cb006d196b5201828e77e1b9a6694fe29750cfda3f3c384226f3391f7960807995e1271a991e","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"4cd9c7a265ccb7da7c0efaeb7635a8f4"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
