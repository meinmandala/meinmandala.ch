<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"1b089cd02af71d6983cf272b7fc9e3c49cfbc6d8614e42919e77e8d2bc077e9d4807d65e497f3c298e3322e20d1bfdf3f9169f013eae6e13fc9cbe4d63a0038aba37d62815cf3d3eeea82ce06e464fc799e4308e9c10b028335b3c95d316b873e4e6da436594721a7ae3d9d748a929910aa4dd14fa9b36aadf61dd72e22a59c6d60c73929755a9a30181d5eed58e39da7f4ed0006070b742940d31cbe1e9086b23532491a4f7fec31bb0879e221bb052f582ca12b42c2186340663120059c323225af948c5f26761c2ba5f7b5c947bfeb1677080095a3b546eb51510f6cc43092acbd2e31df3cf5278e598856de0838f745fed3473ea49655df551b44df859e51fb2c51417cf1b8f561f2ef20914fd97815aac9ee3de0e0626e1aa007be064e67559a71848029e7557b57ecd47010900dae404897f6cd018a23d950ed5611dd5fe42e52487c98f22395bbf542c09db2b824c2dde86a48b77c58b0eb814094b74c80d06ce72ec22fd70836a1d986692c1b1c2629d3df34dccd0604baf9d13fa74ac0cef2a849ed3fd0a90cdb897d16e0764288eeeb8f66e7575b4929fea535a266c2bcf4cec91a654713660101c5e298f41d8a467c58f955e447de5ce35275ec56a7bb4b93a89724ad694ced687de7c149a87b31365a7ceb9e46c62f320e10eeb7365737916f1b774a2665674d9a1e05c2d3748c6e6eaa270570fc200df6d4a10f889b9c405e8be430819f48405fc1d27056ac731aa8086f747376bb3cc5a9f4aa70df878ef3219300a6f863d2838eb8fd6ceaf18e0081a1375bb885961c67eea79f1fae91677bfb3bd95ce76177e78bb1d4aca54d36fd7bd7cc12f97279dcd37790c9e7b4fb333228ea290d7718755dc3202ce4cce83706aa2ea4b7a32fdaaa8917da3716df859c77568d0e60510456a482a058117c80c231ac8f3db2e764fb4432dc04dc042c34fe0e4e4d27142cb3d5f4e44d2fd199a9ae2b6ef9c1615072f805aba1e851f2bf876891f3e667caf70a84e404a1612e8a314d5927cbe217b2760a1c2f2617de1092558fb1f09846e5556b43e30313d95be0312209ac952f9e9f16a0f9e8286ad8e0be2e4e536185be89285d826010093d10cf2c77fd9c1babfa9d2d4ceead72e6f347e172cf3326f5d9872fc5c4d6a8242aa3c04c0985e72c79f4b45fe8e82a49cde4617fe23dd2c76d86ed0cf79a8952866f772e15dc17a4fb56eb4a08432af07a4190278f5baf8bf388e123ec097ca2d1b8edcbebd65879b39c343dde2a520a65d555756a06273d55bf8dfed35711928fbf297155dfd949213d9aef03f6df6c76c557e181d0dd26cac996e3b00014ff3f4da0f62fd5eed3540299941221e6e0092473c27800e7bc258c624e7a8aed2a3e80a71edeb59c60bc74d493d540ef4213f91bdd11d45fa2a8ba6768652be7ac39393d1396120f12b435d6ed32ad36478d8c1769e67270a3f44c8c5e67582a32d79e750c66d0da9aa4fe5e678d9b6ed932a60ce225afeac4d6c0e4d5c5993b63bd6c111a6a4b9b629739810a04caf9571e959f31a119dd1e4ec6c9bc164615b81b6823b66cad28381e2546d7f7b9c001bac4b13928e16969711cb8c0637ef169bb2d9f02339bb509341ebbcd0aed1efdea189562e693a28f517295789f5191caeb09d48ce34fc9bc5f8eaae72e64510391e1fb608968e4c4d8cbdd76c72c3cd1da091551f3ee2ec7b8f91c08032579932c1c8270c73ca571e408d03ba88e184f050aea00b292be57a474fae09be587edd627bb26296bd3f378d25c09be318ab826b09eae403c65a36b2d785df9ba38b066b0319448f41e4d0eddbba3780f65cc414d6a883e67cf1186f2ee0adf8514d5baab6e4fb581404f4c02beb417a05908fa507ddd6342fd385b54a0846010079114ec0a8ebcfcd17286f2454b3f7a86d65e01f60626a4dcf08b464d0e931d172b730dc54f6a167dc8222c299bc878bb277ed3ffb8e2080891b0bbbaf76c6583c33b4624fec54bdf856153d19758a6a75fc93885999f51bef50e65d518da144091e1a98ef8bc2322d6fcd4edde20578f5e198e0e2cd5ddb85f4a595234fc7696c94f94da6ebf5e8298c8d2edde0a940282a74ec8703fba357e242608cd90a1361e38a5ee328eb25caf218561a37a75b934212e536402160554db93287b2e1282aebce79daa66cf0110c0e43bf2095f850e435d398aa5572d402dd1bb2cb441860c2d80f3e84ac1394d157b731efa3a882c41f3349b47ff2396fe896852ef7c1e8cb2683247ef7825500b068bd0a649a1eed0e59897d9061affc59a0c1ed5c0f7e0d6c2348f89e028eda4260e0fda96c8116c6df1a345669bb98c828d58d0e04b408631acdd5ae397609305b17a714bb686c1cdb045cbae8bc68f541e3fb51c8d83c5948124452753d787b5ac10060b236d2b89f03d776485fe1ed4693e105c1d8118fd8467856493977972015468dcc546f06f0caa70ead34d3bc5c5d640d5e343f8c6ff093d943721c042b73e0717e265412760ae4e9acb1f8e10bc2cdbc20237c3c6050bfd3eb4ed325b9aaac4f4dca220a2b41ec15e49c8d870770b396e494e2d7b0baf5f3415997675f921a5442232ac598b0876acb17cbcefa939ee4d3ccce00bda40b66afdc7510b6130b2512b93fcae5a5491dafd07d8efe18510d2563c7a0e4ea06ec164f645331591feec1669a0e32ac0d4b318b69e855851a78a1aef3ba7d4377845fc88f58a41d46db7d475144f90c1c643e773ed75a23f6541d24cc4b1b39705e3d60bfe08bd5292c1132386e5bcb6e6cba168c886b9de4280494a7ccb37f7f3a5ec83787e74230ead138cc3c2b858088827adfc6d93324381e0d8f274a6a64cbf99afc9493bc93addf3cac836c1c0028a576fa482da64d67660d5e0e6cd2164bc6bf173dfce81e4664328b120b1dd2db549133562dc858f051725eb2578a823303537b6d64fd261427f080ec3489b6d1b9730bffa94d9f5d8d09a92ab97e5aa7b39d58fc0773ddc695f5ec5d38691a24992b873e7525bfe7656903641ba7c931572d69110e03166a682c0c00adab347e50de94ad9741541a82e54bdfa9a16ab6759d9b068d6b25d14a5f930df97ea3298d703c1b80cb05bd2fb7f08213712748c8914f9b6a91bea1ea29fe55ffeb4abb71782306864ef3a53c682a69bf28fc97d44b12f8a9fbf5ae31d851c9bb5b36df3aa2cd9606399efaa0d7de433813febbe67736b68b8f05537531facbb3500fcb164bdee3511fd39a121c8788783da2f17660626bdf99629309aa672ceda5187d9006f18d2665fbf1ffaac7de2e2681e75f5fe89693a265311401ffbc1843c201045b6d954db0f6d43e387204e6eba8beace169fe0fa88385bf04d4a7fc44c43670ed3c5db4e3ae4e253342ab6ca6818ccbc607b00afafef04736a71be41c3b302a38857d6cd32884c2e9602b0c6a6748b6205584b4eb5fd5a15d7c0a833b0a330d6421f139f2d0da1aa03b998700e0d6371a35bd9bee7b7edf630993f54172863ab0c07692ee366129e7ff3abebeb691c3b098ae4684e87b6aea2ce0dce61b3685b0f2c4e0550754690f36741e1f0df0e467a2d41c85288ec8d816847c23e3df7f47b6636397f099e8f8879ff006e66b3536a3cb8a7a8a763b77c96e048c4c19a2255bd69a566239ef955782da345ae17e541c616a5c7805a173d695ee9fedd02f556635d27fd270c9a77dd5c0ef9dbeef04c456b695aa8e5cabdad4ef12c3543e257f699de24358bb1a5e8ad03504ace9c8f00851351ec922754eb9a07cfc997133a556c5479eb5367307861668cd73ca6222848287377d64a32ead04146cfcf5736cc0a4d4689ab55028d31188088c7bdcdd205367eef2da3c5fe0f931a426ab7bd6281e08309998200f0cb1c0765a62a928851fb5413949ef9bf3f231770f8b8d0fd3f15b685e077fe00d00c3a7fef56c3694bbd6814a77de80de9c41f1ffe061821626e34478fd2bb1fd6ff9958e1797cfd55ef08b14803d3a2aeab5b681a420e624554780b6ff6f3f4d8a0e7e629dc49d332b3bd133496046839affb7d475eedf391f809ebd92aa92dde8d7ff77689600eb81f50f1fb5e995abe120932eda11dee7abc23401bb1a0d480e5d8dc3e5eb8bb224871e6c27a9078d0a1841c11d0663e2720085893227418633c9d74cfc644701bfbb824c071452bd4906577f3878a814cff2ad83609c0f1a2025a90396832e8c180fa377ebaa07848da62c50d2b6f4850f9aef62f1efd68a70370990f988b185d71a87d52987eb088faee72116087219a926be55666326267b737d30a9ab8f48b49a493655023174e0efa3511b5a45820bcc5aa633742420f3a89c7f6bff28443e1cff1be002539c2bc4c63676fed11dd9596cfd70d9d017b6ac64a8cc2dbf361576aa52bfff0da77b286bb48ce380996de8b3c3a168f2ed48c63d3def86ca87028a1e6e0f78ac87c66994100a5f3e2c1cd1517c0885bbf251f8d8111969e2cdf7e2b09ac2a2ef09502796a7d64c5a32483a198075b0f1a3fc211651a1c37972749a2431f2bee67e2431abf9550e20916af8a5abef49f15f1228348606d23cfeb496dc5615530457bfe0b0ed0abb450cf6f05ae496c564e2783f12135d7fe2f99f1ff91e92bcf787e519e444343afa3bb13fc1da0efe4601ac86e46324f27fe530c3a7dfdd51cb711d718dca49785317668b39d545909fb61807ade9a263a0f65d8a2496d1d4ec75efd38c14ca88f34a1ba65c1e565221f4fb0a7246063eb32dd711156964344ee2f13de706cd7a3ae2e805941a53cb9fc995f9cf7c0897c922c6a12fe94217b9a06e61c711aac24e266df786c5953a1d2918adb511b1f035758855e48cab3bf7624010525a9c0d55dd571b2e2aee813dcaffb44f4490bcf23722a84ab69ba34d26050401b183d305bdd5eb24b7d9bf9a4a0cb2d3d5c605d65097981f2312a7b8fd5a478f566598e0c1ce9b2595102354f22a1534015684acabae5944c935aa2b207375a5229de0ead3613a274cdb196f00459d5307d6a3fe3bfee9dbe3f69a028ba3c0a5a49473e31c579c5f7ca832a2d9e59ca6ca40471a4ada71d6a36de6b79b5fac11891773f037cd0bc3ddffc696b083a03dad7d667cfe034068fb1ecd818fbcebf4a6ea0e5fb7871901430e9b9d0985d56425619feb51fd30d4acecdd09ebcbbea40dcd70d9fee7441e2debe5e0347cc968461722e086b15495307d45bd7b346fa0972193a9866055bc52c67abd8cd5b924a31217de43b486ba65539650a7209bd16b3c1a8d446e85b972823e505b365c209278512ab4231b899148fbd84b4475170cef1b40257bd0cef2612f56380d463889c715410d8a3524c459920247230b01a1576c17b8b16654c7c43f5bc8148bb6f3d35ce38ec6387c50cae8c19045c7dbb633eeea4f71b900e713ebb72e8a2aab75a8a83d8c6f2c3ca0b600b9bb443645363704368a9278cfb98af6241853437a28e504de7b6b9f2262b3d573f49cc6c4eddd3a00ffcd70b55a1315dfeab403ec1e4f6467a896b82a1c617ac4019d3a0daf315e2e290fb57e39f87592c396aa313951e354b229b4e8c3c1d72557af629e29fdb45cd4bc1df38b3988221aa2d1b97443c0037e72bb8e67adebbdad773f2b9e80d803689b0e636463d92b48e668fcf8b5318ccaf2e4ebf1d87c0a29490cf278af2a4ca69f37cdf450d6b5455e6180787c33db63531147e8e52c46768d4e5052a3c769cfecfa85b18be811a4685d9e7e81b3449c14f236e3b03bc7e76bb5d6b768c1faf3d7eddc037201417c0dcee6c2d9d301cec1d30538e5ea0d7fefc05544e7ea6e1f38196d676f9cd47beedf3a316a5099a4815b6f806cd446d13522b7d0bca92cb90c52b535999bc2638ed94463f1700d599588228a8fc9188749c8cb40ff9ab3a369c2b7a356b3dd1cc25f752cd74367675bf576656e4fdd401dfc67db6fb3ed07e72bf1fbd1adb1862122645d2faed61cf3cf9264d65aba652ae0897f8bfccecf05e5d71ebbe55671f6cd27696d24b0906860abcd020d4efd38469a9c90c69a741e43300689bca8c2a2c75eee55e09a657fbb00c53d7a404bd713ed0af9b4e4c32a90fff63c904960880d1c53153f015a3ffeb54ab1b59b11e7b16d05961fb72b2589a9235d76b63630746dee17cdcf91e39801b246288e47a80705c92db78f3e173e71962220573fc6458460801f9a46bb8317c9c24c39cbe7722873c08ce91b0f3a9c644bb1b4e1f64476b1a4e92c7015c431bcb735959bbf6273fe1e35c230e5cbb622db141f55f89ad5c6fe1838f6117b58f4785542004e6cb6a79817a202951376502e46356cedb64db4e81e073d649b77350c4e93eadcddc2573c6aec055aeace709a54d0eda828cdf417aff99b97b5cfc2d91d14cacd2f742d6ececd5f33156d8ec0f844752bf49124cff9128894b36969e5b52b6dfb0aacf10f3c45ddb9907c4d0be52daf66aaf4470a9f702982c1f05baf93acf83362982c25d3b79702ebada6c43541dfc2ca5f6798b006ba24625058f352826673468a8796332b7c4694b09e75198b6b9cd5cf7a3c5bfa93f7a0dd13c32cd4a14e8f889f43ccecf24e604a1cbcb9fba34134e8f6c184b53098a146423b718d47c515890d40fd540ba42be3491b7ab94f868e71875e0c63b3113d365358d4ed2e403a222669800d01892ead2ad69bb149f1a4c5aa4660af6036477b9550d0a23d2819c9ab74901a2f37747ac6b088e88581311b8f37d61a5f73a9c60f7eb2b9f9b71cefb7f2ad6f2e9ab85bae8872831fbf7530dd3571668de84d241f2039051edad1681be1951f61c28bc6f277d99e860de6c5aaf81db83d24354e541387f64266cfb3ac506ea19f505da03d20f19081245c58c7d31962500d96eca7dd35a53e8307929abf75b24265d52c13af21494c4cfcee9891f9658b99b48c3e12abb8a7934e84ee20fd488e2f1b0ea23c31c1274bd57b596c7b158735c43f0a6fa3dae8e0dc2fd6b4c25171fc0b631d1bdba4f9da300795dadd6cc62f1f3904d0f68f34ae856fe980473b014c2301d65e5986d3a7ecd0a9fe4fbad176ea5bc39c45237b87b82900bfab6727889040ac179ddacd24269100eba203ce90cadfd12de1d75f324ca8e72714ef7229180f8e37ece0fcec933e0efdda9b18a2dbf8f6c7d7d3d3f5a8e27baa438d8c3816f3c1e24e5d4576c28249d4e0e8959acfc75d185012910725ade833d79b627779644c002a60522245c6645a44030238c0874910a1375373738fad4f013aa120d160da1c0b5e889b80635ce358bdab0da7e9c62670e40fa2ea77834ca6fce4962bd7e272defdfae78e6b0887bad78022ffb8d78b91bbac7145bcbcae40e0a48ba0ba0cf4ad6e8c20bcf8f8b9da164f7c7790f20135e16842c56d48cab65679458f666096f8b85a631de7bf31255d38049778aad5247c64cddf1bb1bd828db81687f525f334b7d10ef876cc1725b7f6794efa41369470071cbd026b845c6986b970545d60acbf336cf581797e03da6722330e9883b6928adbad9afb127926b60c1c64450f0902eb5f49d6685592b6472dd8e2079be8fe5bfb4c3570c24f897df5b45c664f3d62b0dea5684569b547be4478733b85cdf25b1cb563808f3d42949409bd7a51272771f1f4b106844b8ca04f443b2bb03dac75c5a2afb261d44a7257498ba1151e27296200c8d01b148f1c679813a02839fdcf144c1bf4cf69d6e168195630852fe88d3436e1f150aa8b163c5762553ef2e8ee075d8d3ed6bfbfd697a3fa9bfc3fc28d6bcbe2f9535103becc6b291113709032fae9f41c4c923e5f953b4c79416240afdedf7683a1bf517fd31bfb8c3f20a52590bfd52caa933cdcf2df370e18889a767ca239a6a627e9aba1b10b94b4ef7bba06f14d069c8e8a275da08de3db5839af7bed91b8ef1125f29247e8633b9c8c9ef78032ed042bbdb3a123ba1b0d44c50a7f369bef5a03ddd5b1fdb6643032b26997817c1417d39ef5632b1faeb57f8a1487d36279c913e3624c011058138a394dd19f425e4603bfb25a3fa5b6c1a79f75f7a6c739b2ccea9db1445502e6b8491e11561079d43ebfc25e44248a207767c2dd4b22da403d41899f70f2afbe29f880491fd125678a30b3b08a2afd61bb095165cd6573d4651fc46af082ba266d51fba9f9c270cfff116047bdb822d7cac5dc8698e8ccf0c970629bf17c66382f8caa1e16ec677cd8236c47c65c00f8222fe07d6c394b0a508332d39ff68900af413c0ba932ad7e8c788bb20947176439ebff8db673da0b9913af40e85d0cb0ca3378df8a530fc37469aa3bd4ebe76a91a9a6b628073615fa583bc664a8514329df32041fb25521ff59346e79d041dec9d269dbb7969f6b44a0d1eea46291d74927d343b75e896fbae527d32609b957e1bad0184e82acc15ff69cf9e0da9a8a7e725b066f0be1c0ba812de07c680de08aadbf05c19f9da27f7c4b9d1f6263cb5a40bcb6b89f2cb95916fa9d6577c1b44a6cd668e2feedc01e5abbd19097d9b760fc792aa76d726cc98b7cba022a969df5e74287152ed3d9bd92d9a1bac7da36b6cbe29616ebb237b1f6f82762021f957d2ef2587e82c1e2f1c8ec91fbe4a269dce3a584da7f066c2424597d5794f12ac0340997b6cd937e4f7e77b39588bb08259e1090f4f0102744af3f98b2a042de3d4baebf8cfc9aaa399053785ad9ddc7007e9ac221747380fca7758351aa7f7689409e3f779d97178b0ad6af425183172d5fcdc17c0438755732db2b2e569c0c62047769b59ff814507d81b0eb0af47286cb5fa37543ad3230c8f5ef6e0ecc25dbe4f4dcc7376fd0490ad5d3951b9a1ae485b475c88db8e6cbe8150edbe5fb3114ba18672c6b904e888f7aafdb063eb522ceb31279a13cda6b26b740240f5413ecb0614cf3bc1c4167c8af94ade3c51ae6445ac42d6100e595f88a4903a5fb2d0ef6de5d10399e64d391c2d520ab470941ee9d7c1d2f9d2c5c9ee06680493f2a2e3737cd0d1ba1bd4041aa0393c1c370a6c252bbb281dc67351229b88ecb07f9915a5fced82127a3752b7845c2eefb9c53f248eff6df34b31311c474588c68e2154f0952210e4a58932631e9b6e78fc2bdcfb9dd3ec3ce99705ed5dcb311968b0a37e42c0f6c0f9158b80409666c984e39ffd105e61687e611a1e4c142fade19d261a229ab1fc91e86f56bb20edd9e5739ea1ebdfb543963693d145c25564f9119a5f99fa777d96582e1b11b591005b79a329f9e834e642446523183dc76e7242f11f193e14385c7b5b1c885419709dea9b2bd7ac07941c94c5f7bfa2c274a7ae434783cbe83520be950c4b37dde000b3ea1cdb33e33c6436f7c76eafa3d538c466d0e019d5d49569447b51f9b712bb965f05e8d38d5e11082704b0ecb25d553fc76ba1028539334d67087f17318c52d48e79ce1a5510940295e5f9da8f30f12e01b5533ecdacc037b3465041c29213f45b65bb7a3ae38e2a64f7a03f189e680a6204db4594769ae168bc7faa6ab84e5e6f2409c8a813ca408191275ae012fef9bf0091c5e10647293bfcec13baf9386979d454b8885cc59feb7425de0c04a83769d446a88a8566a9c4033efa1d7c78ce18aba0d11544858da79688bb18c530af7662b16670dad3fbd6cbdf28ffb2e537a56b4c5a32dd1dd0ca0b695ca9f73849f044034fd5b37ecb94b9ee11c1a3bb2346f2ba5a1c5710ccacff6f8cfb4ca0c280042fb77dfc4cd0a57c5a3b7e9a0506b412c4f76b1c2b3fb39731484ba13a62098f108539a78365055026c9e45340610445e4e14afd419dccf2a3d071b92b2ebe39548ad4a4d9a149f1cb434b0ede234ba04fd51bcc43af28f5d8240a330f335b4db6fa37d3d1580dce2d4e0720ea1e89c3a9736e01b8a368905d3d27433f8a89ec47d151e2769418a3454facd59f7ff328e94c5adec91c0c7225fea7cfa0b91f8707931d63213a3f98cbbc6e93e3700911c64069cb30ff39ffc336d87a048ccad95c7e93c58f5bffc48367c7e30e088908be9fe484ba3742cfdf31cee1a26a2c3bfd2c7b89d74ea07ccb73de009054cef4667c78b9399f54cd7f115821cf9107291be7b3a0b5b9aee48259e0d9803e2f3a09bbccf1aa58299784c712a80b5693daab73674b258f2e45c7147226e64bcff555e2e3144da303a00c51e4fbc3420a1cf690152b5a115e3c52d8c772658b54f0a51ac8f61993170b7e81ae4a22f9880140a08dc2ced6dfaf461bb83af7b02b1152bfe6aeea843026dfe67cf5b5f1ad080c3663f925eb3e219ec3b52c8618fa02384de279bcfe9645074238e024c161bfb9f7f15b53fb77accb6e9b33d5ed9aa0c7f920ad47d4c285a6b23757e92cb272b7d769ca658349e8f6f785dbc4b7ff33fd4f1137fb3fcb8d1aeb51d75d4a1fec0ec05a7fb921440805dc15409b4b4255b6d97b3ffae0ceb317aad7c30701c8c45a01ee2f359266f3eb507b0af1afbd599280b6d0e5aac3d747dc3905c176f31a8a484c9e51704ff92d4c618915129a07080a8c1f9077b2f09426b4fb582eb8f75ed0da6ebf95cf3d84d96be3f2e518e6a1e728d0ec1e1ceace4312f57b0a9bf7e1b6e56ae91f2e181fdc61dc10f5c337453883a265abaad647d8df4b9885db96139415450a9991fa5465a77e4a914ca9dd82ad237bba1d79c12101ab3176dc871afa373de48918126eb9e2c89a0e6679722c3686f71c8130ffcc530f15e53b73c2df345bf39c350025a248ab7991a37019407d13df10ed2082e791051e99bde1561dba5ad4ed68cc54a1c4afddbfe84da9bfb4faebb05e712bfd59da3b697b35c58b432c5713412610016095eb39e8ce3eb63695bf22c2fc8aac25ad9d9484e4a236c27759c43e6cce7b91c438d76307a0a2f1e17354da5919f347d02499c49634b2db91b3db70c285a04dec59c6de39b31e9989546c1f0709f74c776a6c384b258227e99140c24f01eb65600f9bacd66ce24b523fffd3f1e6ce95a9f168eec7fecd3c64e8c9c473be6870386808ad7ff7a83accd1a316956c93561dd363e868a76bdad91646e2a0aa9f2449a0992c7e36e75e46a692c177b8eeca9e0c04623090f224193dee91ed8bd95e7cfdfb9b62940a1ee748fcef71227eb1f077d626ccd583dcfe0e9d1778007d37108181c98c7f1155e6583c6b058aa73f11d0d9da6561548bfd0ec1001af93a500ca82092597798d87f9518a71c8df51f0edd2e13df0053ed12de137b4ccf78fa531de93a3f9a924fbafdd085aefb9b976776767dac60cfa459e8c91ad1c440555b8a83df287a4af9ab1ffc8dfe9cbe0dd5aa5a371e093ee031adb98bd65a5a7acdf6e353420d8e7d2cf13f65943bd29ff7c6c359f7c112252088305d659f19b4fa04127b0f360aaf947d56199c83eab5f1d599ce8f41bbbd1108b36503b946c77ee32db7dada5257ff6e73a3a543b343dea3abe479dcf82e64d9897d2f95b20cec55f55541d4c4f8c9556bfee957fdcee609c0f95d0728fecd746168bd0cdff0a6c0249b9305443581c3b7db40da73bd6da2a61f222c22b0890a73a07a333582d4f9e2859201fd6cf74707b119c82486ce2a078f0401d34f864e8958a0a620938fcc0a0170ac187d2233afa6566a79c96709421c891b64b7a01a1dd2ba49ea8fbef3e622176ab936e9e162093dbd2e3cea682f4eff4c438e9d31524c5fbacc057cee68d631ed94415a8136b1347ac47bfca3ba5f0a4faf55a731d4acc870c4ad6c1a472d50cad81e980fd86b9a5c792e1f4ae206d0352c8f0c1628ef011c197af62452f14a96e02af4f725fdafa80ae48486ddf965fe048561e84bd88c6d15ea1ea762425e9bab283e56abb830cce314657b432ba6cae7d0e7bb400b25c9f4bb7611d2b1b63dec0e3ba5b7ae1201e634ed9a5fe7bf76f0137657b5be894776bae094f6b97c31ae417670c3727036b4e07e71cb0fca10dd1f05662507f2505de4ec2d376c20cfad2e03e6a04d7ee2fbe2ada845039168fbf2973715e3b31dfd35cbc7861cd83e6e2859c2b484b8a4aaaf7206f08f665c63f7973d230c8e6bc4c8037396d6c6ff1c1253b77440f49b4bd70fafc3908d79edaa800e01843eb0b5d977a76c91ef886997c9c13fd2923b236264ace20f89ed103809b61fb0fb3154815422837a6112051bce31fa3614c56892aa630c150aa793fd3ceb6a9fcaeb97c6152d9874e7481184d8af8f9ab9915c126efac74c160891e01810b3d285daae1971e8e5ff29c99ed80c56e5305ba256ce99ee6dfbe218a328d0e5ba64ce3899f144a2056653ad5e976ae8c2c36b48a84aa18441204cc96dcbd881555417888af5f36c7bcdcfec39f45d648c89b3259040ed2312e21fc01072c0540dc80dbdaa583f7196ef93811cd3fa805c8d2b59f795fc185aaa407957b27dbc39a6a0b725c8b5f9be8824335c48a19a0276421decb9751e80d1a16fade227cdaf3a9898c9c8f680865bf8478b02ab1c103e7e815243b2930af24b2023541b198ba8512502ba04eb0cf6d97b58e62021968339d02c6b12d95fcf9541fa6d217496a5b","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"4cd9c7a265ccb7da7c0efaeb7635a8f4"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
